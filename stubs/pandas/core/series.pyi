# Stubs for pandas.core.series (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.
# pylint: disable=unused-import,unused-argument,invalid-name,redefined-builtin
# pylint: disable=too-few-public-methods,no-self-use,function-redefined
# pylint: disable=redefined-outer-name,too-many-ancestors,super-init-not-called
# pylint: disable=too-many-arguments,line-too-long,keyword-arg-before-vararg
# pylint: disable=arguments-differ,signature-differs
from typing import Any, Callable, Optional, TYPE_CHECKING
from pandas.core import base, generic
if TYPE_CHECKING:
    import pandas as pd


class Series(base.IndexOpsMixin, generic.NDFrame):
    hasnans: Any = ...
    name: Any = ...

    def __init__(self, data: Optional[Any] = ..., index: Optional[Any] = ...,
                 dtype: Optional[Any] = ..., name: Optional[Any] = ...,
                 copy: bool = ..., fastpath: bool = ...) -> None:
        ...

    @property
    def _constructor_expanddim(self) -> Any:
        ...

    @classmethod
    def from_array(cls, arr: Any, index: Optional[Any] = ...,
                   name: Optional[Any] = ..., dtype: Optional[Any] = ...,
                   copy: bool = ..., fastpath: bool = ...) -> Any:
        ...

    @property  # type: ignore
    def name(self) -> Any:
        ...

    @name.setter
    def name(self, value: Any) -> None:
        ...

    @property
    def dtype(self) -> Any:
        ...

    @property
    def dtypes(self) -> Any:
        ...

    @property
    def ftype(self) -> Any:
        ...

    @property
    def ftypes(self) -> Any:
        ...

    @property
    def values(self) -> Any:
        ...

    def get_values(self) -> Any:
        ...

    @property
    def asobject(self) -> Any:
        ...

    def ravel(self, order: str = ...) -> Any:
        ...

    def compress(self, condition: Any, *args: Any, **kwargs: Any) -> Any:
        ...

    def nonzero(self) -> Any:
        ...

    def put(self, *args: Any, **kwargs: Any) -> None:
        ...

    def __len__(self) -> int:
        ...

    def view(self, dtype: Optional[Any] = ...) -> Any:
        ...

    def __array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any,
                        **kwargs: Any) -> Any:
        ...

    def __array__(self, dtype: Optional[Any] = ...) -> Any:
        ...

    @property
    def real(self) -> Any:
        ...

    @real.setter
    def real(self, v: Any) -> None:
        ...

    @property
    def imag(self) -> Any:
        ...

    @imag.setter
    def imag(self, v: Any) -> None:
        ...

    __float__: Any = ...
    __long__: Any = ...
    __int__: Any = ...

    @property
    def axes(self) -> Any:
        ...

    def __getitem__(self, key: Any) -> Any:
        ...

    def __setitem__(self, key: Any, value: Any) -> None:
        ...

    def repeat(self, repeats: Any, axis: Optional[Any] = ...) -> Any:
        ...

    def get_value(self, label: Any, takeable: bool = ...) -> Any:
        ...

    def set_value(self, label: Any, value: Any, takeable: bool = ...) -> Any:
        ...

    index: Any = ...

    def reset_index(self, level: Optional[Any] = ..., drop: bool = ...,
                    name: Optional[Any] = ..., inplace: bool = ...) -> Any:
        ...

    def to_string(self, buf: Optional[Any] = ..., na_rep: str = ...,
                  float_format: Optional[Any] = ..., header: bool = ...,
                  index: bool = ..., length: bool = ..., dtype: bool = ...,
                  name: bool = ..., max_rows: Optional[Any] = ...,
                  min_rows: Optional[Any] = ...) -> Any:
        ...

    def items(self) -> Any:
        ...

    def iteritems(self) -> Any:
        ...

    def keys(self) -> Any:
        ...

    def to_dict(self, into: Any = ...) -> Any:
        ...

    def to_frame(self, name: Optional[Any] = ...) -> 'pd.DataFrame':
        ...

    def to_sparse(self, kind: str = ...,
                  fill_value: Optional[Any] = ...) -> Any:
        ...

    def count(self, level: Optional[Any] = ...) -> Any:
        ...

    def mode(self, dropna: bool = ...) -> Any:
        ...

    def unique(self) -> Any:
        ...

    def drop_duplicates(self, keep: str = ..., inplace: bool = ...) -> Any:
        ...

    def duplicated(self, keep: str = ...) -> Any:
        ...

    def idxmin(self, axis: int = ..., skipna: bool = ..., *args: Any,
               **kwargs: Any) -> Any:
        ...

    def idxmax(self, axis: int = ..., skipna: bool = ..., *args: Any,
               **kwargs: Any) -> Any:
        ...

    argmin: Any = ...
    argmax: Any = ...

    def round(self, decimals: int = ..., *args: Any, **kwargs: Any) -> Any:
        ...

    def quantile(self, q: float = ..., interpolation: str = ...) -> Any:
        ...

    def corr(self, other: Any, method: str = ...,
             min_periods: Optional[Any] = ...) -> Any:
        ...

    def cov(self, other: Any, min_periods: Optional[Any] = ...) -> Any:
        ...

    def diff(self, periods: int = ...) -> Any:
        ...

    def autocorr(self, lag: int = ...) -> Any:
        ...

    def dot(self, other: Any) -> Any:
        ...

    def __matmul__(self, other: Any) -> Any:
        ...

    def __rmatmul__(self, other: Any) -> Any:
        ...

    def searchsorted(self,
                     value: Any,
                     side: str = ...,
                     sorter: Optional[Any] = ...) -> Any:
        ...

    def append(self,
               to_append: Any,
               ignore_index: bool = ...,
               verify_integrity: bool = ...) -> Any:
        ...

    def _binop(self, other: Any, func: Any, level: Optional[Any] = None,
               fill_value: Optional[Any] = None) -> Any:
        ...

    def combine(self,
                other: Any,
                func: Any,
                fill_value: Optional[Any] = ...) -> Any:
        ...

    def combine_first(self, other: Any) -> Any:
        ...

    def update(self, other: Any) -> None:
        ...

    def sort_values(self, by: Optional[Any] = ..., axis: int = ...,
                    ascending: bool = ...,
                    inplace: bool = ...,
                    kind: str = ...,
                    na_position: str = ...) -> Any:
        ...

    def sort_index(self, axis: int = ..., level: Optional[Any] = ...,
                   ascending: bool = ..., inplace: bool = ..., kind: str = ...,
                   na_position: str = ..., sort_remaining: bool = ...) -> Any:
        ...

    def argsort(self, axis: int = ..., kind: str = ...,
                order: Optional[Any] = ...) -> Any:
        ...

    def nlargest(self, n: int = ..., keep: str = ...) -> Any:
        ...

    def nsmallest(self, n: int = ..., keep: str = ...) -> Any:
        ...

    def swaplevel(self,  # type: ignore
                  i: int = ...,
                  j: int = ...,
                  copy: bool = ...) -> Any:
        ...

    def reorder_levels(self, order: Any) -> Any:
        ...

    def explode(self) -> 'Series':
        ...

    def unstack(self,
                level: int = ...,
                fill_value: Optional[Any] = ...) -> Any:
        ...

    def map(self, arg: Any, na_action: Optional[Any] = ...) -> Any:
        ...

    def aggregate(self, func: Any, axis: int = ..., *args: Any,
                  **kwargs: Any) -> Any:
        ...

    agg: Any = ...

    def transform(self, func: Any, axis: int = ..., *args: Any,
                  **kwargs: Any) -> Any:
        ...

    def apply(self, func: Any, convert_dtype: bool = ..., args: Any = ...,
              **kwds: Any) -> Any:
        ...

    def align(self, other: Any, join: str = ..., axis: Optional[Any] = ...,
              level: Optional[Any] = ..., copy: bool = ...,
              fill_value: Optional[Any] = ..., method: Optional[Any] = ...,
              limit: Optional[Any] = ..., fill_axis: int = ...,
              broadcast_axis: Optional[Any] = ...) -> Any:
        ...

    def rename(self,  # type: ignore
               index: Optional[Any] = ..., **kwargs: Any) -> Any:
        ...

    def reindex(self,  # type: ignore
                index: Optional[Any] = ..., **kwargs: Any) -> Any:
        ...

    def drop(self, labels: Optional[Any] = ..., axis: int = ...,
             index: Optional[Any] = ..., columns: Optional[Any] = ...,
             level: Optional[Any] = ..., inplace: bool = ...,
             errors: str = ...) -> Any:
        ...

    def fillna(self, value: Optional[Any] = ..., method: Optional[Any] = ...,
               axis: Optional[Any] = ..., inplace: bool = ...,
               limit: Optional[Any] = ..., downcast: Optional[Any] = ...,
               **kwargs: Any) -> Any:
        ...

    def replace(self, to_replace: Optional[Any] = ...,
                value: Optional[Any] = ..., inplace: bool = ...,
                limit: Optional[Any] = ..., regex: bool = ...,
                method: str = ...) -> Any:
        ...

    def shift(self, periods: int = ..., freq: Optional[Any] = ...,
              axis: int = ..., fill_value: Optional[Any] = ...) -> Any:
        ...

    def memory_usage(self,  # type: ignore
                     index: bool = ...,
                     deep: bool = ...) -> Any:
        ...

    def take(self, indices: Any, axis: int = ..., is_copy: bool = ...,
             **kwargs: Any) -> Any:
        ...

    def isin(self, values: Any) -> Any:
        ...

    def between(self, left: Any, right: Any, inclusive: bool = ...) -> Any:
        ...

    def to_csv(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def isna(self) -> Any:
        ...

    def isnull(self) -> Any:
        ...

    def notna(self) -> Any:
        ...

    def notnull(self) -> Any:
        ...

    def dropna(self, axis: int = ..., inplace: bool = ...,
               **kwargs: Any) -> Any:
        ...

    def valid(self, inplace: bool = ..., **kwargs: Any) -> Any:
        ...

    def to_timestamp(self, freq: Optional[Any] = ..., how: str = ...,
                     copy: bool = ...) -> Any:
        ...

    def to_period(self, freq: Optional[Any] = ..., copy: bool = ...) -> Any:
        ...

    def __add__(self, other: Any) -> Any:
        ...

    def __radd__(self, other: Any) -> Any:
        ...

    def __sub__(self, other: Any) -> Any:
        ...

    def __mul__(self, other: Any) -> Any:
        ...

    def __rmul__(self, other: Any) -> Any:
        ...

    def __pow__(self, other: Any) -> Any:
        ...

    def __mod__(self, other: Any) -> Any:
        ...

    def __floordiv__(self, other: Any) -> Any:
        ...

    def __truediv__(self, other: Any) -> Any:
        ...

    def __divmod__(self, other: Any) -> Any:
        ...

    def __eq__(self, other: Any) -> Any:
        ...

    def __ne__(self, other: Any) -> Any:
        ...

    def __lt__(self, other: Any) -> Any:
        ...

    def __gt__(self, other: Any) -> Any:
        ...

    def __le__(self, other: Any) -> Any:
        ...

    def __ge__(self, other: Any) -> Any:
        ...

    def __remainder__(self, other: Any) -> Any:
        ...

    def __and__(self, other: Any) -> Any:
        ...

    def __rand__(self, other: Any) -> Any:
        ...

    def __iand__(self, other: Any) -> Any:
        ...

    dt: Any = ...
    cat: Any = ...
    plot: Any = ...
    sparse: Any = ...
    hist: Any = ...
