# Stubs for pandas.core.window (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.
# pylint: disable=unused-argument,super-init-not-called,redefined-outer-name
# pylint: disable=no-self-use,arguments-differ,too-many-arguments
# pylint: disable=dangerous-default-value,too-many-ancestors

from pandas._typing import Axis
from pandas.core.base import PandasObject, SelectionMixin
from pandas.core.groupby.base import GroupByMixin
from typing import Any, Optional, Set

from pandas.util._decorators import Appender
from pandas.core.generic import _shared_docs

class _Window(PandasObject, SelectionMixin):
    exclusions: Set[str] = ...
    obj: Any = ...
    on: Any = ...
    closed: Any = ...
    window: Any = ...
    min_periods: Any = ...
    center: Any = ...
    win_type: Any = ...
    win_freq: Any = ...
    axis: Any = ...

    def __init__(self, obj: Any, window: Any = None,
                 min_periods: Optional[int] = None,
                 center: Optional[bool] = False,
                 win_type: Optional[str] = None,
                 axis: Axis = 0, on: Optional[str] = None,
                 closed: Optional[str] = None, **kwargs: Any) -> None:
        ...

    @property
    def is_datetimelike(self) -> Optional[bool]:
        ...

    @property
    def is_freq_type(self) -> bool:
        ...

    def validate(self) -> None:
        ...

    def __getattr__(self, attr: Any) -> Any:
        ...

    def __iter__(self) -> None:
        ...

    def aggregate(self, func: Any, *args: Any, **kwargs: Any) -> Any:
        ...

    agg: Any = aggregate


class Window(_Window):
    def validate(self) -> None:
        ...

    @Appender(_shared_docs["aggregate"])
    def aggregate(self, arg: Any, *args: Any, **kwargs: Any) -> Any:
        ...

    agg: Any = aggregate

    def sum(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def mean(self, *args: Any, **kwargs: Any) -> Any:
        ...


class _GroupByMixin(GroupByMixin):
    def __init__(self, obj: Any, *args: Any, **kwargs: Any) -> None:
        ...

    count: Any = ...
    corr: Any = ...
    cov: Any = ...


class _Rolling(_Window):
    ...


class _Rolling_and_Expanding(_Rolling):
    def count(self) -> Any:
        ...

    def apply(self, func: Any, raw: Optional[Any] = None,
              args: Any = (), kwargs: Any = {}) -> Any:
        ...

    def sum(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def max(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def min(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def mean(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def median(self, **kwargs: Any) -> Any:
        ...

    def std(self, ddof: int = 1, *args: Any, **kwargs: Any) -> Any:
        ...

    def var(self, ddof: int = 1, *args: Any, **kwargs: Any) -> Any:
        ...

    def skew(self, **kwargs: Any) -> Any:
        ...

    def kurt(self, **kwargs: Any) -> Any:
        ...

    def quantile(self, quantile: Any, interpolation: str = "linear",
                 **kwargs: Any) -> Any:
        ...

    def cov(self, other: Optional[Any] = None, pairwise: Optional[Any] = None,
            ddof: int = 1, **kwargs: Any) -> Any:
        ...

    def corr(self, other: Optional[Any] = None, pairwise: Optional[Any] = None,
             **kwargs: Any) -> Any:
        ...


class Rolling(_Rolling_and_Expanding):
    def is_datetimelike(self) -> bool:
        ...

    win_freq: Any = ...
    window: Any = ...
    win_type: str = ...
    min_periods: int = ...

    def validate(self) -> None:
        ...

    def aggregate(self, arg: Any, *args: Any, **kwargs: Any) -> Any:
        ...

    agg: Any = ...
    def count(self) -> Any:
        ...

    def apply(self, func: Any, raw: Optional[Any] = ..., args: Any = ...,
              kwargs: Any = ...) -> Any:
        ...

    def sum(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def max(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def min(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def mean(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def median(self, **kwargs: Any) -> Any:
        ...

    def std(self, ddof: int = ..., *args: Any, **kwargs: Any) -> Any:
        ...

    def var(self, ddof: int = ..., *args: Any, **kwargs: Any) -> Any:
        ...

    def skew(self, **kwargs: Any) -> Any:
        ...

    def kurt(self, **kwargs: Any) -> Any:
        ...

    def quantile(self, quantile: Any, interpolation: str = ...,
                 **kwargs: Any) -> Any:
        ...

    def cov(self, other: Optional[Any] = ..., pairwise: Optional[Any] = ...,
            ddof: int = ..., **kwargs: Any) -> Any:
        ...

    def corr(self, other: Optional[Any] = ..., pairwise: Optional[Any] = ...,
             **kwargs: Any) -> Any:
        ...


class RollingGroupby(_GroupByMixin, Rolling):
    ...


class Expanding(_Rolling_and_Expanding):
    def __init__(self, obj: Any, min_periods: int = 1, center: bool = False,
                 axis: int = 0, **kwargs: Any) -> None:
        ...

    def aggregate(self, arg: Any, *args: Any, **kwargs: Any) -> Any:
        ...

    agg: Any = aggregate

    def count(self, **kwargs: Any) -> Any:
        ...

    def apply(self, func: Any, raw: Optional[Any] = None, args: Any = (),
              kwargs: Any = {}) -> Any:
        ...

    def sum(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def max(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def min(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def mean(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def median(self, **kwargs: Any) -> Any:
        ...

    def std(self, ddof: int = ..., *args: Any, **kwargs: Any) -> Any:
        ...

    def var(self, ddof: int = ..., *args: Any, **kwargs: Any) -> Any:
        ...

    def skew(self, **kwargs: Any) -> Any:
        ...

    def kurt(self, **kwargs: Any) -> Any:
        ...

    def quantile(self, quantile: Any, interpolation: str = "linear",
                 **kwargs: Any) -> Any:
        ...

    def cov(self, other: Optional[Any] = ..., pairwise: Optional[Any] = ...,
            ddof: int = ..., **kwargs: Any) -> Any:
        ...

    def corr(self, other: Optional[Any] = ..., pairwise: Optional[Any] = ...,
             **kwargs: Any) -> Any:
        ...


class ExpandingGroupby(_GroupByMixin, Expanding):
    ...


class EWM(_Rolling):
    obj: Any = ...
    com: Any = ...
    min_periods: Any = ...
    adjust: Any = ...
    ignore_na: Any = ...
    axis: Any = ...
    on: Any = ...

    def __init__(self, obj: Any, com: Optional[Any] = None,
                 span: Optional[Any] = None, halflife: Optional[Any] = None,
                 alpha: Optional[Any] = None, min_periods: int = 0,
                 adjust: bool = True, ignore_na: bool = False, axis: int = 0,
                 ) -> None:
        ...

    def aggregate(self, arg: Any, *args: Any, **kwargs: Any):
        ...

    agg: Any = ...
    def mean(self, *args: Any, **kwargs: Any) -> Any:
        ...

    def std(self, bias: bool = ..., *args: Any, **kwargs: Any) -> Any:
        ...

    vol: Any = ...
    def var(self, bias: bool = ..., *args: Any, **kwargs: Any) -> Any:
        ...

    def cov(self, other: Optional[Any] = ..., pairwise: Optional[Any] = ...,
            bias: bool = ..., **kwargs: Any) -> Any:
        ...

    def corr(self, other: Optional[Any] = ..., pairwise: Optional[Any] = ...,
             **kwargs: Any) -> Any:
        ...


def rolling(obj: Any, win_type: Optional[Any] = None, **kwds: Any) -> Any:
    ...


def expanding(obj: Any, **kwds: Any) -> Any:
    ...


def ewm(obj: Any, **kwds: Any) -> Any:
    ...
