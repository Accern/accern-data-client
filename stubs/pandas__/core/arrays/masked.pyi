"""
This type stub file was generated by pyright.
"""

import numpy as np
from typing import Any, TYPE_CHECKING, TypeVar, overload
from pandas._typing import ArrayLike, AstypeArg, NpDtype, PositionalIndexer, Scalar, ScalarIndexer, SequenceIndexer, Shape, npt, type_t
from pandas.util._decorators import cache_readonly, doc
from pandas.core.dtypes.base import ExtensionDtype
from pandas.core.arraylike import OpsMixin
from pandas.core.arrays import BooleanArray, ExtensionArray
from pandas import Series

if TYPE_CHECKING:
    ...
BaseMaskedArrayT = TypeVar("BaseMaskedArrayT", bound="BaseMaskedArray")
class BaseMaskedDtype(ExtensionDtype):
    """
    Base class for dtypes for BasedMaskedArray subclasses.
    """
    name: str
    base = ...
    type: type
    na_value = ...
    @cache_readonly
    def numpy_dtype(self) -> np.dtype:
        """Return an instance of our numpy dtype"""
        ...
    
    @cache_readonly
    def kind(self) -> str:
        ...
    
    @cache_readonly
    def itemsize(self) -> int:
        """Return the number of bytes in this dtype"""
        ...
    
    @classmethod
    def construct_array_type(cls) -> type_t[BaseMaskedArray]:
        """
        Return the array type associated with this dtype.

        Returns
        -------
        type
        """
        ...
    


class BaseMaskedArray(OpsMixin, ExtensionArray):
    """
    Base class for masked arrays (which use _data and _mask to store the data).

    numpy based
    """
    _internal_fill_value: Scalar
    _data: np.ndarray
    _mask: np.ndarray
    _truthy_value = Scalar
    _falsey_value = Scalar
    def __init__(self, values: np.ndarray, mask: np.ndarray, copy: bool = ...) -> None:
        ...
    
    @property
    def dtype(self) -> BaseMaskedDtype:
        ...
    
    @overload
    def __getitem__(self, item: ScalarIndexer) -> Any:
        ...
    
    @overload
    def __getitem__(self: BaseMaskedArrayT, item: SequenceIndexer) -> BaseMaskedArrayT:
        ...
    
    def __getitem__(self: BaseMaskedArrayT, item: PositionalIndexer) -> BaseMaskedArrayT | Any:
        ...
    
    @doc(ExtensionArray.fillna)
    def fillna(self: BaseMaskedArrayT, value=..., method=..., limit=...) -> BaseMaskedArrayT:
        ...
    
    def __setitem__(self, key, value) -> None:
        ...
    
    def __iter__(self): # -> Generator[object | Any, None, None]:
        ...
    
    def __len__(self) -> int:
        ...
    
    @property
    def shape(self) -> Shape:
        ...
    
    @property
    def ndim(self) -> int:
        ...
    
    def swapaxes(self: BaseMaskedArrayT, axis1, axis2) -> BaseMaskedArrayT:
        ...
    
    def delete(self: BaseMaskedArrayT, loc, axis: int = ...) -> BaseMaskedArrayT:
        ...
    
    def reshape(self: BaseMaskedArrayT, *args, **kwargs) -> BaseMaskedArrayT:
        ...
    
    def ravel(self: BaseMaskedArrayT, *args, **kwargs) -> BaseMaskedArrayT:
        ...
    
    @property
    def T(self: BaseMaskedArrayT) -> BaseMaskedArrayT:
        ...
    
    def __invert__(self: BaseMaskedArrayT) -> BaseMaskedArrayT:
        ...
    
    def to_numpy(self, dtype: npt.DTypeLike | None = ..., copy: bool = ..., na_value: Scalar = ...) -> np.ndarray:
        """
        Convert to a NumPy Array.

        By default converts to an object-dtype NumPy array. Specify the `dtype` and
        `na_value` keywords to customize the conversion.

        Parameters
        ----------
        dtype : dtype, default object
            The numpy dtype to convert to.
        copy : bool, default False
            Whether to ensure that the returned value is a not a view on
            the array. Note that ``copy=False`` does not *ensure* that
            ``to_numpy()`` is no-copy. Rather, ``copy=True`` ensure that
            a copy is made, even if not strictly necessary. This is typically
            only possible when no missing values are present and `dtype`
            is the equivalent numpy dtype.
        na_value : scalar, optional
             Scalar missing value indicator to use in numpy array. Defaults
             to the native missing value indicator of this array (pd.NA).

        Returns
        -------
        numpy.ndarray

        Examples
        --------
        An object-dtype is the default result

        >>> a = pd.array([True, False, pd.NA], dtype="boolean")
        >>> a.to_numpy()
        array([True, False, <NA>], dtype=object)

        When no missing values are present, an equivalent dtype can be used.

        >>> pd.array([True, False], dtype="boolean").to_numpy(dtype="bool")
        array([ True, False])
        >>> pd.array([1, 2], dtype="Int64").to_numpy("int64")
        array([1, 2])

        However, requesting such dtype will raise a ValueError if
        missing values are present and the default missing value :attr:`NA`
        is used.

        >>> a = pd.array([True, False, pd.NA], dtype="boolean")
        >>> a
        <BooleanArray>
        [True, False, <NA>]
        Length: 3, dtype: boolean

        >>> a.to_numpy(dtype="bool")
        Traceback (most recent call last):
        ...
        ValueError: cannot convert to bool numpy array in presence of missing values

        Specify a valid `na_value` instead

        >>> a.to_numpy(dtype="bool", na_value=False)
        array([ True, False, False])
        """
        ...
    
    @overload
    def astype(self, dtype: npt.DTypeLike, copy: bool = ...) -> np.ndarray:
        ...
    
    @overload
    def astype(self, dtype: ExtensionDtype, copy: bool = ...) -> ExtensionArray:
        ...
    
    @overload
    def astype(self, dtype: AstypeArg, copy: bool = ...) -> ArrayLike:
        ...
    
    def astype(self, dtype: AstypeArg, copy: bool = ...) -> ArrayLike:
        ...
    
    __array_priority__ = ...
    def __array__(self, dtype: NpDtype | None = ...) -> np.ndarray:
        """
        the array interface, return my values
        We return an object array here to preserve our scalar values
        """
        ...
    
    _HANDLED_TYPES: tuple[type, ...]
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): # -> _NotImplementedType | tuple[Unknown, ...] | Any | tuple[BooleanArray | IntegerArray | FloatingArray | Any, ...] | object | BooleanArray | IntegerArray | FloatingArray:
        ...
    
    def __arrow_array__(self, type=...):
        """
        Convert myself into a pyarrow Array.
        """
        ...
    
    def isna(self) -> np.ndarray:
        ...
    
    @property
    def nbytes(self) -> int:
        ...
    
    def take(self: BaseMaskedArrayT, indexer, *, allow_fill: bool = ..., fill_value: Scalar | None = ..., axis: int = ...) -> BaseMaskedArrayT:
        ...
    
    def isin(self, values) -> BooleanArray:
        ...
    
    def copy(self: BaseMaskedArrayT) -> BaseMaskedArrayT:
        ...
    
    @doc(ExtensionArray.factorize)
    def factorize(self, na_sentinel: int = ...) -> tuple[np.ndarray, ExtensionArray]:
        ...
    
    def value_counts(self, dropna: bool = ...) -> Series:
        """
        Returns a Series containing counts of each unique value.

        Parameters
        ----------
        dropna : bool, default True
            Don't include counts of missing values.

        Returns
        -------
        counts : Series

        See Also
        --------
        Series.value_counts
        """
        ...
    
    @doc(ExtensionArray.equals)
    def equals(self, other) -> bool:
        ...
    
    def sum(self, *, skipna=..., min_count=..., axis: int | None = ..., **kwargs): # -> FloatingArray | BooleanArray | TimedeltaArray | IntegerArray | ndarray | NAType:
        ...
    
    def prod(self, *, skipna=..., min_count=..., axis: int | None = ..., **kwargs): # -> FloatingArray | BooleanArray | TimedeltaArray | IntegerArray | ndarray | NAType:
        ...
    
    def min(self, *, skipna=..., axis: int | None = ..., **kwargs): # -> NAType:
        ...
    
    def max(self, *, skipna=..., axis: int | None = ..., **kwargs): # -> NAType:
        ...
    
    def any(self, *, skipna: bool = ..., **kwargs): # -> bool_ | object:
        """
        Return whether any element is truthy.

        Returns False unless there is at least one element that is truthy.
        By default, NAs are skipped. If ``skipna=False`` is specified and
        missing values are present, similar :ref:`Kleene logic <boolean.kleene>`
        is used as for logical operations.

        .. versionchanged:: 1.4.0

        Parameters
        ----------
        skipna : bool, default True
            Exclude NA values. If the entire array is NA and `skipna` is
            True, then the result will be False, as for an empty array.
            If `skipna` is False, the result will still be True if there is
            at least one element that is truthy, otherwise NA will be returned
            if there are NA's present.
        **kwargs : any, default None
            Additional keywords have no effect but might be accepted for
            compatibility with NumPy.

        Returns
        -------
        bool or :attr:`pandas.NA`

        See Also
        --------
        numpy.any : Numpy version of this method.
        BaseMaskedArray.all : Return whether all elements are truthy.

        Examples
        --------
        The result indicates whether any element is truthy (and by default
        skips NAs):

        >>> pd.array([True, False, True]).any()
        True
        >>> pd.array([True, False, pd.NA]).any()
        True
        >>> pd.array([False, False, pd.NA]).any()
        False
        >>> pd.array([], dtype="boolean").any()
        False
        >>> pd.array([pd.NA], dtype="boolean").any()
        False
        >>> pd.array([pd.NA], dtype="Float64").any()
        False

        With ``skipna=False``, the result can be NA if this is logically
        required (whether ``pd.NA`` is True or False influences the result):

        >>> pd.array([True, False, pd.NA]).any(skipna=False)
        True
        >>> pd.array([1, 0, pd.NA]).any(skipna=False)
        True
        >>> pd.array([False, False, pd.NA]).any(skipna=False)
        <NA>
        >>> pd.array([0, 0, pd.NA]).any(skipna=False)
        <NA>
        """
        ...
    
    def all(self, *, skipna: bool = ..., **kwargs): # -> bool_ | object:
        """
        Return whether all elements are truthy.

        Returns True unless there is at least one element that is falsey.
        By default, NAs are skipped. If ``skipna=False`` is specified and
        missing values are present, similar :ref:`Kleene logic <boolean.kleene>`
        is used as for logical operations.

        .. versionchanged:: 1.4.0

        Parameters
        ----------
        skipna : bool, default True
            Exclude NA values. If the entire array is NA and `skipna` is
            True, then the result will be True, as for an empty array.
            If `skipna` is False, the result will still be False if there is
            at least one element that is falsey, otherwise NA will be returned
            if there are NA's present.
        **kwargs : any, default None
            Additional keywords have no effect but might be accepted for
            compatibility with NumPy.

        Returns
        -------
        bool or :attr:`pandas.NA`

        See Also
        --------
        numpy.all : Numpy version of this method.
        BooleanArray.any : Return whether any element is truthy.

        Examples
        --------
        The result indicates whether all elements are truthy (and by default
        skips NAs):

        >>> pd.array([True, True, pd.NA]).all()
        True
        >>> pd.array([1, 1, pd.NA]).all()
        True
        >>> pd.array([True, False, pd.NA]).all()
        False
        >>> pd.array([], dtype="boolean").all()
        True
        >>> pd.array([pd.NA], dtype="boolean").all()
        True
        >>> pd.array([pd.NA], dtype="Float64").all()
        True

        With ``skipna=False``, the result can be NA if this is logically
        required (whether ``pd.NA`` is True or False influences the result):

        >>> pd.array([True, True, pd.NA]).all(skipna=False)
        <NA>
        >>> pd.array([1, 1, pd.NA]).all(skipna=False)
        <NA>
        >>> pd.array([True, False, pd.NA]).all(skipna=False)
        False
        >>> pd.array([1, 0, pd.NA]).all(skipna=False)
        False
        """
        ...
    


