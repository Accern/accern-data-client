"""
This type stub file was generated by pyright.
"""

import numpy as np
from typing import Any, Literal, TYPE_CHECKING, TypeVar, overload
from pandas._libs.arrays import NDArrayBacked
from pandas._typing import ArrayLike, Dtype, F, NumpySorter, NumpyValueArrayLike, PositionalIndexer2D, PositionalIndexerTuple, ScalarIndexer, SequenceIndexer, TakeIndexer, npt
from pandas.util._decorators import doc
from pandas.core.array_algos.transforms import shift
from pandas.core.arrays.base import ExtensionArray

NDArrayBackedExtensionArrayT = TypeVar("NDArrayBackedExtensionArrayT", bound="NDArrayBackedExtensionArray")
if TYPE_CHECKING:
    ...
def ravel_compat(meth: F) -> F:
    """
    Decorator to ravel a 2D array before passing it to a cython operation,
    then reshape the result to our own shape.
    """
    ...

class NDArrayBackedExtensionArray(NDArrayBacked, ExtensionArray):
    """
    ExtensionArray that is backed by a single NumPy ndarray.
    """
    _ndarray: np.ndarray
    def view(self, dtype: Dtype | None = ...) -> ArrayLike:
        ...
    
    def take(self: NDArrayBackedExtensionArrayT, indices: TakeIndexer, *, allow_fill: bool = ..., fill_value: Any = ..., axis: int = ...) -> NDArrayBackedExtensionArrayT:
        ...
    
    def equals(self, other) -> bool:
        ...
    
    def argmin(self, axis: int = ..., skipna: bool = ...): # -> ndarray | integer[Unknown] | int:
        ...
    
    def argmax(self, axis: int = ..., skipna: bool = ...): # -> ndarray | integer[Unknown] | int:
        ...
    
    def unique(self: NDArrayBackedExtensionArrayT) -> NDArrayBackedExtensionArrayT:
        ...
    
    @doc(ExtensionArray.searchsorted)
    def searchsorted(self, value: NumpyValueArrayLike | ExtensionArray, side: Literal["left", "right"] = ..., sorter: NumpySorter = ...) -> npt.NDArray[np.intp] | np.intp:
        ...
    
    @doc(ExtensionArray.shift)
    def shift(self, periods=..., fill_value=..., axis=...):
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    @overload
    def __getitem__(self, key: ScalarIndexer) -> Any:
        ...
    
    @overload
    def __getitem__(self: NDArrayBackedExtensionArrayT, key: SequenceIndexer | PositionalIndexerTuple) -> NDArrayBackedExtensionArrayT:
        ...
    
    def __getitem__(self: NDArrayBackedExtensionArrayT, key: PositionalIndexer2D) -> NDArrayBackedExtensionArrayT | Any:
        ...
    
    @doc(ExtensionArray.fillna)
    def fillna(self: NDArrayBackedExtensionArrayT, value=..., method=..., limit=...) -> NDArrayBackedExtensionArrayT:
        ...
    
    def insert(self: NDArrayBackedExtensionArrayT, loc: int, item) -> NDArrayBackedExtensionArrayT:
        """
        Make new ExtensionArray inserting new item at location. Follows
        Python list.append semantics for negative values.

        Parameters
        ----------
        loc : int
        item : object

        Returns
        -------
        type(self)
        """
        ...
    
    def value_counts(self, dropna: bool = ...): # -> Series:
        """
        Return a Series containing counts of unique values.

        Parameters
        ----------
        dropna : bool, default True
            Don't include counts of NA values.

        Returns
        -------
        Series
        """
        ...
    


