"""
This type stub file was generated by pyright.
"""

from typing import TypeVar, final
from pandas._typing import ArrayLike, DtypeObj, Shape
from pandas.core.base import PandasObject
from pandas.core.indexes.api import Index

"""
Base class for the internal managers. Both BlockManager and ArrayManager
inherit from this class.
"""
T = TypeVar("T", bound="DataManager")
class DataManager(PandasObject):
    axes: list[Index]
    @property
    def items(self) -> Index:
        ...
    
    @final
    def __len__(self) -> int:
        ...
    
    @property
    def ndim(self) -> int:
        ...
    
    @property
    def shape(self) -> Shape:
        ...
    
    def reindex_indexer(self: T, new_axis, indexer, axis: int, fill_value=..., allow_dups: bool = ..., copy: bool = ..., consolidate: bool = ..., only_slice: bool = ...) -> T:
        ...
    
    @final
    def reindex_axis(self: T, new_index: Index, axis: int, fill_value=..., consolidate: bool = ..., only_slice: bool = ...) -> T:
        """
        Conform data manager to new index.
        """
        ...
    
    @final
    def equals(self, other: object) -> bool:
        """
        Implementation for DataFrame.equals
        """
        ...
    
    def apply(self: T, f, align_keys: list[str] | None = ..., ignore_failures: bool = ..., **kwargs) -> T:
        ...
    
    @final
    def isna(self: T, func) -> T:
        ...
    
    def is_consolidated(self) -> bool:
        ...
    
    def consolidate(self: T) -> T:
        ...
    


class SingleDataManager(DataManager):
    ndim = ...
    @final
    @property
    def array(self) -> ArrayLike:
        """
        Quick access to the backing array of the Block or SingleArrayManager.
        """
        ...
    
    def setitem_inplace(self, indexer, value) -> None:
        """
        Set values with indexer.

        For Single[Block/Array]Manager, this backs s[indexer] = value

        This is an inplace version of `setitem()`, mutating the manager/values
        in place, not returning a new Manager (and Block), and thus never changing
        the dtype.
        """
        ...
    
    def grouped_reduce(self, func, ignore_failures: bool = ...):
        """
        ignore_failures : bool, default False
            Not used; for compatibility with ArrayManager/BlockManager.
        """
        ...
    
    @classmethod
    def from_array(cls, arr: ArrayLike, index: Index):
        ...
    


def interleaved_dtype(dtypes: list[DtypeObj]) -> DtypeObj | None:
    """
    Find the common dtype for `blocks`.

    Parameters
    ----------
    blocks : List[DtypeObj]

    Returns
    -------
    dtype : np.dtype, ExtensionDtype, or None
        None is returned when `blocks` is empty.
    """
    ...

